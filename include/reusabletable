
// import React, { useEffect, useState } from 'react';
// import { get } from '../../../services/api-services';
// import {
//     Box,
//     Typography,
//     Button,
//     LinearProgress,
//     Card,
//     CardContent,
//     IconButton,
//     Tooltip,
//     Table,
//     TableBody,
//     TableCell,
//     TableContainer,
//     TableHead,
//     TableRow,
//     Paper
// } from '@mui/material';
// import EditIcon from '@mui/icons-material/Edit';
// import InfoIcon from '@mui/icons-material/Info';
// import { useParams } from 'react-router-dom';
// import EnrollProgramDialog from '../profileModel-DialogBox/AddEnrollProgramDialog';

// const Programs = ({ userId, tabIndex }) => {
//     const [paymentData, setPaymentData] = useState([]);
//     const [isDialogOpen, setIsDialogOpen] = useState(false);
//     const [loading, setLoading] = useState(true);
//     const { id } = useParams();

//     useEffect(() => {
//         const fetchPayments = async () => {
//             try {
//                 const response = await get(`/UserPrograms?filter={"where" : {"customerId" : "628f3383238fb97f020d75e8"}, "include" : "invoice", "order" : "createdAt DESC"}`);
//                 setPaymentData(response.data);
//             } catch (error) {
//                 console.error('Error fetching payment data:', error);
//             } finally {
//                 setLoading(false);
//             }
//         };

//         fetchPayments();
//     }, [id]); // Re-run when id changes

//     const addUserProgramDialog = () => {
//         // Handle add user program dialog
//     };

//     const editUserProgramDialog = (userId, programId) => {
//         // Handle edit user program dialog
//     };

//     const invoiceUrl = (invoiceId) => {
//         // Handle viewing the invoice
//     };

//     if (loading) {
//         return <Typography>Loading...</Typography>;
//     }
//     const handleEnrolltoProgram = () => setIsDialogOpen(true);
//     const handleDialogClose = () => setIsDialogOpen(false);


//     return (
//         <Box sx={{ marginLeft: '20px', marginRight: '10px' }}>
//             <Box display="flex" justifyContent="space-between" alignItems="center" sx={{ marginBottom: 2 }}>
//                 <Typography variant="h6" sx={{ fontWeight: 500 }}>
//                     Enrolled Programs
//                 </Typography>
//                 <Button
//                     variant="text"
//                     color="secondary"
//                     onClick={handleEnrolltoProgram}
//                 >
//                     Enroll new programs
//                 </Button>
//             </Box>

//             {paymentData.length === 0 && (
//                 <Typography align="center">Enroll program for the user!</Typography>
//             )}

//             {paymentData.map((enrollProgram) => (
//                 <Card
//                     key={enrollProgram.id}
//                     sx={{
//                         marginBottom: 2,
//                         backgroundColor: enrollProgram.status === 'active' ? '#fff' : '#f5f5f5',
//                         boxShadow: 1,
//                     }}
//                 >
//                     <CardContent>
//                         <Box display="flex" justifyContent="space-between" alignItems="center">
//                             <Typography variant="h6">
//                                 {enrollProgram.invoice?.purchaseProgram?.title} (₹
//                                 {enrollProgram.invoice?.purchaseProgram?.price})
//                             </Typography>
//                             <IconButton onClick={() => editUserProgramDialog(userId, enrollProgram.id)}>
//                                 <EditIcon color="action" />
//                             </IconButton>
//                         </Box>

//                         <Typography variant="body2" color="textSecondary">
//                             {enrollProgram.invoice?.purchaseProgram?.duration} Days
//                         </Typography>
//                         <Typography variant="body2" color="textSecondary">
//                             {new Date(enrollProgram.invoice?.enrollOn).toLocaleDateString()} To
//                             {new Date(enrollProgram.invoice?.completedOn).toLocaleDateString()}
//                         </Typography>

//                         <Typography
//                             variant="body2"
//                             color={enrollProgram.remainingDay === '0' ? 'primary' : 'textSecondary'}
//                         >
//                             {enrollProgram.remainingDay === '0' ? 'Completed' : 'In Progress'}
//                         </Typography>

//                         <LinearProgress
//                             variant="determinate"
//                             value={
//                                 enrollProgram.remainingDay === '0'
//                                     ? 100
//                                     : ((enrollProgram.invoice?.purchaseProgram?.duration -
//                                         enrollProgram.remainingDay) /
//                                         enrollProgram.invoice?.purchaseProgram?.duration) *
//                                     100
//                             }
//                             color="secondary"
//                         />

//                         <Typography variant="body2" color="primary">
//                             {enrollProgram.remainingDay}d Remaining
//                         </Typography>

//                         <Box display="flex" flexWrap="wrap">
//                             <Typography variant="body2">
//                                 Discount: ₹{enrollProgram.invoice?.feeDiscount || '0'}
//                                 <Tooltip title={enrollProgram.invoice?.discountNote || ''} arrow>
//                                     <InfoIcon color="action" />
//                                 </Tooltip>
//                             </Typography>

//                             <Typography variant="body2">
//                                 Net Fee: ₹{enrollProgram.programNetAmt}
//                             </Typography>

//                             <Typography
//                                 variant="body2"
//                                 color={enrollProgram.remainAmount <= 1 ? 'primary' : 'error'}
//                             >
//                                 Fee Status: {enrollProgram.remainAmount <= 1 ? '✔ Paid' : `(₹${enrollProgram.remainAmount}) Due`}
//                             </Typography>

//                             <Button onClick={() => invoiceUrl(enrollProgram.invoice?.id)}>VIEW INVOICE</Button>
//                         </Box>

//                         {enrollProgram.payments?.length > 0 && (
//                             <TableContainer component={Paper} sx={{ marginTop: 2 }}>
//                                 <Table>
//                                     <TableHead>
//                                         <TableRow>
//                                             <TableCell>Paid On</TableCell>
//                                             <TableCell>Paid Amount</TableCell>
//                                             <TableCell>Remaining Amount</TableCell>
//                                             <TableCell>Payment Mode</TableCell>
//                                             <TableCell>Comments</TableCell>
//                                             <TableCell>Action</TableCell>
//                                         </TableRow>
//                                     </TableHead>
//                                     <TableBody>
//                                         {enrollProgram.payments.map((payment) => (
//                                             <TableRow key={payment.id}>
//                                                 <TableCell>{new Date(payment.paidOn).toLocaleDateString()}</TableCell>
//                                                 <TableCell>₹{payment.amount}</TableCell>
//                                                 <TableCell>₹{payment.remainingAmount}</TableCell>
//                                                 <TableCell>{payment.mode}</TableCell>
//                                                 <TableCell>{payment.comment}</TableCell>
//                                                 <TableCell>
//                                                     <IconButton
//                                                         onClick={() =>
//                                                             editUserProgramDialog(payment.id, enrollProgram.remainAmount)
//                                                         }
//                                                         disabled={enrollProgram.remainAmount <= 1}
//                                                     >
//                                                         <EditIcon />
//                                                     </IconButton>
//                                                 </TableCell>
//                                             </TableRow>
//                                         ))}
//                                     </TableBody>
//                                 </Table>
//                             </TableContainer>
//                         )}
//                     </CardContent>
//                 </Card>
//             ))}
//             <EnrollProgramDialog
//                 open={isDialogOpen}
//                 onClose={handleDialogClose}
//             />
//         </Box>
//     );
// };

// export default Programs;

import React, { useEffect, useState } from 'react';
import { get } from '../../../services/api-services';
import {
    Box,
    Typography,
    Button,
    Card,
    CardContent,
    IconButton,
    Table,
    TableBody,
    TableCell,
    TableContainer,
    TableHead,
    TableRow,
    Paper,
    LinearProgress,
} from '@mui/material';
import EditIcon from '@mui/icons-material/Edit';
import EnrollProgramDialog from '../profileModel-DialogBox/AddEnrollProgramDialog';

const Programs = () => {
    const [userPrograms, setUserPrograms] = useState([]);
    const [paymentData, setPaymentData] = useState([]);
    const [isDialogOpen, setIsDialogOpen] = useState(false);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const fetchData = async () => {
            try {
                const [userProgramsResponse, paymentResponse] = await Promise.all([
                    get(
                        `/UserPrograms?filter={"where": {"customerId": ${id}}, "include": "invoice", "order": "createdAt DESC"}`
                    ),
                    get(
                        `/api/Payments?filter={"where": {"customerId": "${id}", "programId": "5cb44b428de7bf1f69d82f20", "invoiceId": "628f3f2d238fb97f020d75f1"}, "order": "paidOn"}&access_token=hgo6OsMfAwBSdWMqtX2JqJGfANQcEuaNNlT7tTMHzGe8AdsUXJUmdEVsPufXMZKZ`
                    ),
                ]);

                setUserPrograms(userProgramsResponse.data);
                setPaymentData(paymentResponse.data);
            } catch (error) {
                console.error('Error fetching data:', error);
            } finally {
                setLoading(false);
            }
        };

        fetchData();
    }, []);

    const handleEnrollToProgram = () => setIsDialogOpen(true);
    const handleDialogClose = () => setIsDialogOpen(false);

    if (loading) {
        return <Typography>Loading...</Typography>;
    }

    return (
        <Box sx={{ marginLeft: '20px', marginRight: '10px' }}>
            <Box display="flex" justifyContent="space-between" alignItems="center" sx={{ marginBottom: 2 }}>
                <Typography variant="h6" sx={{ fontWeight: 500 }}>
                    Enrolled Programs
                </Typography>
                <Button variant="text" color="secondary" onClick={handleEnrollToProgram}>
                    Enroll new programs
                </Button>
            </Box>

            {/* User Programs */}
            {userPrograms.length === 0 ? (
                <Typography align="center">No enrolled programs found!</Typography>
            ) : (
                userPrograms.map((program) => (
                    <Card key={program.id} sx={{ marginBottom: 2, backgroundColor: '#f5f5f5' }}>
                        <CardContent>
                            <Typography variant="h6">
                                {program.invoice?.purchaseProgram?.title} (₹
                                {program.invoice?.purchaseProgram?.price})
                            </Typography>
                            <Typography variant="body2" color="textSecondary">
                                {program.invoice?.purchaseProgram?.duration} Days
                            </Typography>
                            <LinearProgress
                                variant="determinate"
                                value={
                                    ((program.invoice?.purchaseProgram?.duration - program.remainingDay) /
                                        program.invoice?.purchaseProgram?.duration) *
                                    100
                                }
                                color="secondary"
                            />
                            <Typography variant="body2">Remaining: {program.remainingDay} days</Typography>
                        </CardContent>
                    </Card>
                ))
            )}

            {/* Payment Data */}
            {paymentData.length > 0 && (
                <TableContainer component={Paper} sx={{ marginTop: 4 }}>
                    <Typography variant="h6" sx={{ marginBottom: 2 }}>
                        Payment History
                    </Typography>
                    <Table>
                        <TableHead>
                            <TableRow>
                                <TableCell>Paid On</TableCell>
                                <TableCell>Amount</TableCell>
                                <TableCell>Remaining Amount</TableCell>
                                <TableCell>Mode</TableCell>
                                <TableCell>Comments</TableCell>
                            </TableRow>
                        </TableHead>
                        <TableBody>
                            {paymentData.map((payment) => (
                                <TableRow key={payment.id}>
                                    <TableCell>{new Date(payment.paidOn).toLocaleDateString()}</TableCell>
                                    <TableCell>₹{payment.amount}</TableCell>
                                    <TableCell>₹{payment.remainingAmount}</TableCell>
                                    <TableCell>{payment.mode}</TableCell>
                                    <TableCell>{payment.comment}</TableCell>
                                </TableRow>
                            ))}
                        </TableBody>
                    </Table>
                </TableContainer>
            )}

            <EnrollProgramDialog open={isDialogOpen} onClose={handleDialogClose} />
        </Box>
    );
};

export default Programs;



// import React, { useState, useEffect } from 'react';
// import { Button, Typography, Box, Divider, IconButton } from '@mui/material';
// import { Add as AddIcon } from '@mui/icons-material';
// import { Chart as ChartJS, LineElement, CategoryScale, LinearScale, PointElement, Tooltip, Legend } from 'chart.js';
// import { Line } from 'react-chartjs-2';
// import { get } from '../../../services/api-services';
// import { useParams } from 'react-router-dom';
// import { useCommon } from '../../../context/CommonContext'
// import AddMeasurmentDialog from '../profileModel-DialogBox/AddMeasurmentDialog';
// // Register required Chart.js components
// ChartJS.register(LineElement, CategoryScale, LinearScale, PointElement, Tooltip, Legend);

// const Measurement = () => {
//     // const userId = 1;  // Hardcoded userId (You can replace this as needed)
//     const [measurements, setMeasurements] = useState([]);
//     const [loading, setLoading] = useState(true);
//     const { id } = useParams();
//     const [isOpneDialog, setIsOpenDialog] = useState(false)
//     const { setSnackbar, currentUser, setCurrentUser } = useCommon();
//     const [measurementType, setMeasurementType] = useState(null);

//     const fetchData = async () => {
//         const url = `/Measurements?filter={"where":{"customerId":"${id}"},"order":"recordedAt DESC"}`;

//         try {
//             const response = await get(
//                 url
//             );
//             if (response && response.data) {
//                 setMeasurements(response.data);
//                 setLoading(false);

//             }
//         } catch (error) {
//             console.error('Error fetching measurements:', error);
//             setLoading(false);
//         }
//     };
//     // Fetch measurements from API
//     useEffect(() => {
//         fetchData();
//     }, [id]);
//     // console.log(measurements)
//     const dummyLabels = [];
//     const chartOptions = {
//         responsive: true,
//         plugins: {
//             legend: {
//                 display: false,
//             },
//         },
//         scales: {
//             x: {
//                 beginAtZero: true,
//             },
//             y: {
//                 beginAtZero: true,
//             },
//         },
//     };

//     // Create chart data for each measurement type
//     const generateChartData = (label, color) => {
//         // console.log('Filtered Data:', measurements.filter(measurement => measurement.type === 'skeletalMuscleFat'));
//         const filteredData = measurements.filter(measurement => measurement.type === label);
//         // console.log(filteredData, "jhcfdewf")
//         const data = filteredData.map(item => item.value);


//         return [
//             {
//                 label,
//                 data,
//                 borderColor: color,
//                 backgroundColor: `${color}33`,
//                 fill: true,
//                 tension: 0.4,
//             },
//         ];
//     };

//     const renderSection = (title, currentValue, chartData, chartLabels, chartOptions, onClickHandler, type, value) => (
//         <Box display="flex" flexDirection="row" alignItems="center" sx={{ marginLeft: 2 }}>
//             <Box flex="1">
//                 <Typography variant="h6" sx={{ fontWeight: 300, cursor: 'pointer', fontSize: '18px' }} onClick={onClickHandler}>
//                     {title}
//                 </Typography>
//             </Box>
//             <Box flex="1">
//                 <Line data={{ labels: chartLabels, datasets: chartData }} options={chartOptions} height={60} />
//             </Box>
//             <Box flex="1" display="flex" justifyContent="flex-end" alignItems="center">
//                 <Typography variant="h5" sx={{ fontWeight: 300, fontSize: '24px' }}>
//                     {currentValue}
//                     {currentValue && <span style={{ fontSize: '14px', color: '#757575' }}> kg</span>}
//                 </Typography>
//                 <IconButton onClick={() => { setMeasurementType(type); setIsOpenDialog(true); }}>
//                     <AddIcon sx={{ color: 'primary.main' }} />
//                 </IconButton>
//             </Box>
//         </Box>
//     );

//     if (loading) {
//         return <Typography>Loading...</Typography>;
//     }

//     return (
//         <Box sx={{ background: '#ffffff', boxShadow: 1, borderRadius: 1, p: 2 }}>
//             <Typography variant="h6" sx={{ fontWeight: 500, fontSize: '18px', marginBottom: 2 }}>
//                 Measurements
//             </Typography>
//             <Divider />
//             {renderSection(
//                 'Weight',
//                 measurements.find(m => m.type === 'weight')?.value || 'N/A',
//                 generateChartData('weight', 'blue'),
//                 dummyLabels,
//                 chartOptions,
//                 () => setIsOpenDialog(true),
//                 'weight'
//             )}
//             <Divider />
//             {renderSection(
//                 'Waist Size',
//                 measurements.find(m => m.type === 'waistSize')?.value || 'N/A',
//                 generateChartData('waist_size', 'green'),
//                 dummyLabels,
//                 chartOptions,
//                 () => setIsOpenDialog(true),
//                 'waistSize'
//             )}
//             <Divider />
//             {renderSection(
//                 'Chest Size',
//                 measurements.find(m => m.type === 'chestSize')?.value || 'N/A',
//                 generateChartData('chest_size', 'red'),
//                 dummyLabels,
//                 chartOptions,
//                 () => setIsOpenDialog(true),
//                 'chestSize'
//             )}
//             <Divider />
//             {renderSection(
//                 'Hips Size',
//                 measurements.find(m => m.type === 'hipsSize')?.value || 'N/A',
//                 generateChartData('hips_size', 'purple'),
//                 dummyLabels,
//                 chartOptions,
//                 () => setIsOpenDialog(true),
//                 'hipsSize'
//             )}
//             <Divider />
//             {renderSection(
//                 'Thighs Size',
//                 measurements.find(m => m.type === 'thighsSize')?.value || 'N/A',
//                 generateChartData('thighs_size', 'orange'),
//                 dummyLabels,
//                 chartOptions,
//                 () => setIsOpenDialog(true),
//                 'thighsSize'
//             )}
//             <Divider />
//             {renderSection(
//                 'Arms Size',
//                 measurements.find(m => m.type === 'armsSize')?.value || 'N/A',
//                 generateChartData('arms_size', 'pink'),
//                 dummyLabels,
//                 chartOptions,
//                 () => setIsOpenDialog(true),
//                 'armsSize'
//             )}
//             <Divider />
//             {renderSection(
//                 'Overall Body Fat',
//                 measurements.find(m => m.type === 'overallBodyFat')?.value || 'N/A',
//                 generateChartData('body_fat', 'brown'),
//                 dummyLabels,
//                 chartOptions,
//                 () => setIsOpenDialog(true),
//                 'overallBodyFat'
//             )}
//             <Divider />
//             {renderSection(
//                 'Skeletal Muscle',
//                 measurements.find(m => m.type === 'skeletalMuscleFat')?.value || 'N/A',
//                 generateChartData('skeletal_muscle', 'cyan'),
//                 dummyLabels,
//                 chartOptions,
//                 () => setIsOpenDialog(true),
//                 'skeletalMuscleFat'
//             )}
//             <Divider />
//             {renderSection(
//                 'Visceral Fat',
//                 measurements.find(m => m.type === 'visceralFat')?.value || 'N/A',
//                 generateChartData('skeletal_muscle', 'cyan'),
//                 dummyLabels,
//                 chartOptions,
//                 () => setIsOpenDialog(true),
//                 'visceralFat'
//             )}
//             <Divider />
//             {renderSection(
//                 'Height',
//                 measurements.find(m => m.type === 'height')?.value || 'N/A',
//                 generateChartData('skeletal_muscle', 'cyan'),
//                 dummyLabels,
//                 chartOptions,
//                 () => setIsOpenDialog(true),
//                 'height'
//             )}
//             <Divider />
//             {renderSection(
//                 'Subcutaneous fat',
//                 measurements.find(m => m.type === 'subcutaneousFat')?.value || 'N/A',
//                 generateChartData('skeletal_muscle', 'cyan'),
//                 dummyLabels,
//                 chartOptions,
//                 () => setIsOpenDialog(true),
//                 'subcutaneousFat'
//             )}
//             <Divider />
//             {renderSection(
//                 'Basal Metabolic Rate(BMR)',
//                 measurements.find(m => m.type === 'bmr')?.value || 'N/A',
//                 generateChartData('skeletal_muscle', 'cyan'),
//                 dummyLabels,
//                 chartOptions,
//                 () => setIsOpenDialog(true),
//                 'bmr'
//             )}
//             {/* <Divider />
//             {renderSection(
//                 'Height',
//                 measurements.find(m => m.type === 'height')?.value || 'N/A',
//                 generateChartData('skeletal_muscle', 'cyan'),
//                 dummyLabels,
//                 chartOptions,
//                 () => console.log(`Add skeletal muscle fat for user ${userId}`)
//             )} */}
//             <Divider />
//             {renderSection(
//                 'Neck Size',
//                 measurements.find(m => m.type === 'neck')?.value || 'N/A',
//                 generateChartData('skeletal_muscle', 'cyan'),
//                 dummyLabels,
//                 chartOptions,
//                 () => setIsOpenDialog(true),
//                 'neck'
//             )}
//             <AddMeasurmentDialog
//                 open={isOpneDialog}
//                 onClose={() => setIsOpenDialog(false)}
//                 type={measurementType}
//             />
//         </Box>
//     );
// };

// export default Measurement;



import React, { useState, useEffect } from 'react';
import { Button, Typography, Box, Divider, IconButton, Card, CardContent } from '@mui/material';
import { Add as AddIcon } from '@mui/icons-material';
import { get } from '../../../services/api-services';
import { useParams } from 'react-router-dom';
import { useCommon } from '../../../context/CommonContext';
import AddMeasurmentDialog from '../profileModel-DialogBox/AddMeasurmentDialog';
import NeckSizeGraph from '../profileModel-DialogBox/Ghraph'; // Assuming NeckSizeGraph component is imported here

const Measurement = () => {
    const [measurements, setMeasurements] = useState([]);
    const [loading, setLoading] = useState(true);
    const { id } = useParams();
    const [isOpneDialog, setIsOpenDialog] = useState(false);
    const { setSnackbar, currentUser, setCurrentUser } = useCommon();
    const [measurementType, setMeasurementType] = useState(null);

    const fetchData = async () => {
        const url = `/Measurements?filter={"where":{"customerId":"${id}"},"order":"recordedAt DESC"}`;

        try {
            const response = await get(url);
            if (response && response.data) {
                setMeasurements(response.data);
                setLoading(false);
            }
        } catch (error) {
            console.error('Error fetching measurements:', error);
            setLoading(false);
        }
    };

    useEffect(() => {
        fetchData();
    }, [id]);

    const renderSection = (title, currentValue, onClickHandler, type) => (
        <Box display="flex" flexDirection="row" alignItems="center" sx={{ marginLeft: 2 }}>
            <Box flex="1">
                <Typography variant="h6" sx={{ fontWeight: 300, cursor: 'pointer', fontSize: '18px' }} onClick={onClickHandler}>
                    {title}
                </Typography >
            </Box>
            <Box flex="1">
            <Typography variant="h6" sx={{ fontWeight: 300, cursor: 'pointer', fontSize: '18px' }} >
                {/* <Card>
                    <CardContent> */}
                    <NeckSizeGraph  type={type} showLine={false} /> {/* Replaced chart with NeckSizeGraph */}
                    {/* </CardContent>
                
                </Card> */}
                </Typography>
                
            </Box>
            <Box flex="1" display="flex" justifyContent="flex-end" alignItems="center">
                <Typography variant="h5" sx={{ fontWeight: 300, fontSize: '24px' }}>
                    {currentValue}
                    {currentValue && <span style={{ fontSize: '14px', color: '#757575' }}> kg</span>}
                </Typography>
                <IconButton onClick={() => { setMeasurementType(type); setIsOpenDialog(true); }}>
                    <AddIcon sx={{ color: 'primary.main' }} />
                </IconButton>
            </Box>
        </Box>
    );

    if (loading) {
        return <Typography>Loading...</Typography>;
    }

    return (
        <Box sx={{ background: '#ffffff', boxShadow: 1, borderRadius: 1, p: 2 }}>
            <Typography variant="h6" sx={{ fontWeight: 500, fontSize: '18px', marginBottom: 2 }}>
                Measurements
            </Typography>
            <Divider />
            {renderSection(
                'Weight',
                measurements.find(m => m.type === 'weight')?.value || 'N/A',
                () => setIsOpenDialog(true),
                'weight'
            )}
            <Divider />
            {renderSection(
                'Waist Size',
                measurements.find(m => m.type === 'waistSize')?.value || 'N/A',
                () => setIsOpenDialog(true),
                'waistSize'
            )}
            <Divider />
            {renderSection(
                'Chest Size',
                measurements.find(m => m.type === 'chestSize')?.value || 'N/A',
                () => setIsOpenDialog(true),
                'chestSize'
            )}
            <Divider />
            {renderSection(
                'Hips Size',
                measurements.find(m => m.type === 'hipsSize')?.value || 'N/A',
                () => setIsOpenDialog(true),
                'hipsSize'
            )}
            <Divider />
            {renderSection(
                'Thighs Size',
                measurements.find(m => m.type === 'thighsSize')?.value || 'N/A',
                () => setIsOpenDialog(true),
                'thighsSize'
            )}
            <Divider />
            {renderSection(
                'Arms Size',
                measurements.find(m => m.type === 'armsSize')?.value || 'N/A',
                () => setIsOpenDialog(true),
                'armsSize'
            )}
            <Divider />
            {renderSection(
                'Overall Body Fat',
                measurements.find(m => m.type === 'overallBodyFat')?.value || 'N/A',
                () => setIsOpenDialog(true),
                'overallBodyFat'
            )}
            <Divider />
            {renderSection(
                'Skeletal Muscle',
                measurements.find(m => m.type === 'skeletalMuscleFat')?.value || 'N/A',
                () => setIsOpenDialog(true),
                'skeletalMuscleFat'
            )}
            <Divider />
            {renderSection(
                'Visceral Fat',
                measurements.find(m => m.type === 'visceralFat')?.value || 'N/A',
                () => setIsOpenDialog(true),
                'visceralFat'
            )}
            <Divider />
            {renderSection(
                'Height',
                measurements.find(m => m.type === 'height')?.value || 'N/A',
                () => setIsOpenDialog(true),
                'height'
            )}
            <Divider />
            {renderSection(
                'Subcutaneous fat',
                measurements.find(m => m.type === 'subcutaneousFat')?.value || 'N/A',
                () => setIsOpenDialog(true),
                'subcutaneousFat'
            )}
            <Divider />
            {renderSection(
                'Basal Metabolic Rate(BMR)',
                measurements.find(m => m.type === 'bmr')?.value || 'N/A',
                () => setIsOpenDialog(true),
                'bmr'
            )}
            <Divider />
            {renderSection(
                'Neck Size',
                measurements.find(m => m.type === 'neck')?.value || 'N/A',
                () => setIsOpenDialog(true),
                'neck'
            )}
            <AddMeasurmentDialog
                open={isOpneDialog}
                onClose={() => setIsOpenDialog(false)}
                type={measurementType}
            />
        </Box>
    );
};

export default Measurement;



// import React, { useState, useEffect } from 'react';
// import Button from '@mui/material/Button';
// import Dialog from '@mui/material/Dialog';
// import DialogActions from '@mui/material/DialogActions';
// import DialogContent from '@mui/material/DialogContent';
// import DialogTitle from '@mui/material/DialogTitle';
// import CircularProgress from '@mui/material/CircularProgress';
// import { useParams } from 'react-router-dom';
// import { get } from '../../../services/api-services';
// import DateShow from '../../date-filed/DateShow';
// import EditIcon from '@mui/icons-material/Edit';
// import { Grid, IconButton, Typography } from '@mui/material';


// export default function AddMeasurementDialog({ open, onClose, type }) {
//     const { id } = useParams();
//     const [measurements, setMeasurements] = useState([]);
//     const [loading, setLoading] = useState(true);

//     const fetchData = async () => {
//         const url = `/Measurements?filter={"where":{"customerId":"${id}","type":"${type}"},"order":"recordedAt DESC","limit":30}`;
//         try {
//             const response = await get(url);
//             if (response && response.data) {
//                 setMeasurements(response.data);
//             }
//         } catch (error) {
//             console.error('Error fetching measurements:', error);
//         } finally {
//             setLoading(false);
//         }
//     };


//     useEffect(() => {
//         if (open) {
//             fetchData();
//         }
//     }, [open]);

//     return (
//         <Dialog
//             fullWidth
//             open={open}
//             onClose={onClose}
//             aria-labelledby="measurement-dialog-title"
//         >
//             <DialogTitle id="measurement-dialog-title">
//                 Add Weight
//             </DialogTitle>
//             <Grid container spacing={2}>
//                 <Typography></Typography>
//                 <DialogContent>
//                     {loading ? (
//                         <div style={{ textAlign: 'center', padding: '20px' }}>
//                             <CircularProgress />
//                         </div>
//                     ) : measurements.length > 0 ? (
//                         <ul>
//                             {measurements.map((measurement) => (
//                                 <li key={measurement.id}>

//                                     <Grid item xs={6} className="" >
//                                         <DateShow date={measurement.recordedAt} /> {measurement.value}{measurement.unit}
//                                     </Grid>
//                                     <Grid item xs={6} className="" >
//                                         <IconButton>
//                                             <EditIcon sx={{ color: 'primary.main' }} />
//                                         </IconButton>
//                                     </Grid>
//                                     {/* <DateShow date={measurement.recordedAt} />: {measurement.value}:{measurement.unit} */}
//                                     {/* <IconButton>
//                                     <EditIcon sx={{ color: 'primary.main' }} />
//                                 </IconButton> */}
//                                 </li>
//                             ))}
//                         </ul>
//                     ) : (
//                         <p>No measurements available.</p>
//                     )}
//                 </DialogContent>

//             </Grid>
//             <DialogActions>
//                 <Button onClick={onClose}>Cancel</Button>
//             </DialogActions>
//         </Dialog>
//     );
// }

// import React, { useState, useEffect } from 'react';
// import Button from '@mui/material/Button';
// import Dialog from '@mui/material/Dialog';
// import DialogActions from '@mui/material/DialogActions';
// import DialogContent from '@mui/material/DialogContent';
// import DialogTitle from '@mui/material/DialogTitle';
// import CircularProgress from '@mui/material/CircularProgress';
// import { useParams } from 'react-router-dom';
// import { get } from '../../../services/api-services';
// import DateShow from '../../date-filed/DateShow';
// import EditIcon from '@mui/icons-material/Edit';
// import { Grid, IconButton, Typography, Box } from '@mui/material';

// export default function AddMeasurementDialog({ open, onClose, type }) {
//     const { id } = useParams();
//     const [measurements, setMeasurements] = useState([]);
//     const [loading, setLoading] = useState(true);

//     const fetchData = async () => {
//         const url = `/Measurements?filter={"where":{"customerId":"${id}","type":"${type}"},"order":"recordedAt DESC","limit":30}`;
//         try {
//             const response = await get(url);
//             if (response && response.data) {
//                 setMeasurements(response.data);
//             }
//         } catch (error) {
//             console.error('Error fetching measurements:', error);
//         } finally {
//             setLoading(false);
//         }
//     };

//     useEffect(() => {
//         if (open) {
//             fetchData();
//         }
//     }, [open]);

//     return (
//         <Dialog
//             fullWidth
//             open={open}
//             onClose={onClose}
//             aria-labelledby="measurement-dialog-title"
//         >
//             <DialogTitle id="measurement-dialog-title">
//                 Add Weight
//             </DialogTitle>
//             <DialogContent>
//                 {loading ? (
//                     <div style={{ textAlign: 'center', padding: '20px' }}>
//                         <CircularProgress />
//                     </div>
//                 ) : measurements.length > 0 ? (
//                     <div>
//                         {measurements.map((measurement) => (
//                             <Box
//                                 key={measurement.id}
//                                 display="flex"
//                                 alignItems="center"
//                                 justifyContent="space-between"
//                                 padding="8px 0"
//                                 borderBottom="1px solid #f0f0f0"
//                             >
//                                 {/* Left Side: Date */}
//                                 <Typography variant="body2">
//                                     <DateShow date={measurement.recordedAt} />
//                                 </Typography>

//                                 {/* Right Side: Value and Edit Icon */}
//                                 <Box display="flex" alignItems="center" gap={1}>
//                                     <Typography variant="body2">
//                                         {measurement.value} {measurement.unit}
//                                     </Typography>
//                                     <IconButton>
//                                         <EditIcon sx={{ color: 'primary.main' }} />
//                                     </IconButton>
//                                 </Box>
//                             </Box>
//                         ))}
//                     </div>
//                 ) : (
//                     <Typography>No measurements available.</Typography>
//                 )}
//             </DialogContent>
//             <DialogActions>
//                 <Button onClick={onClose}>Cancel</Button>
//             </DialogActions>
//         </Dialog>
//     );
// }


import React, { useState, useEffect } from 'react';
import Button from '@mui/material/Button';
import Dialog from '@mui/material/Dialog';
import DialogActions from '@mui/material/DialogActions';
import DialogContent from '@mui/material/DialogContent';
import DialogTitle from '@mui/material/DialogTitle';
import CircularProgress from '@mui/material/CircularProgress';
import { useParams } from 'react-router-dom';
import { get } from '../../../services/api-services';
import DateShow from '../../date-filed/DateShow';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import { Grid, IconButton, Typography, Box, TextField } from '@mui/material';
import NeckSizeGraph from './Ghraph';

export default function AddMeasurementDialog({ open, onClose, type }) {
    const { id } = useParams();
    const [measurements, setMeasurements] = useState([]);
    const [loading, setLoading] = useState(true);
    const [editDialogOpen, setEditDialogOpen] = useState(false);
    const [selectedMeasurement, setSelectedMeasurement] = useState(null);
    const [editingId, setEditingId] = useState(null);
    const [editableFields, setEditableFields] = useState({});

    const fetchData = async () => {
        const url = `/Measurements?filter={"where":{"customerId":"${id}","type":"${type}"},"order":"recordedAt DESC","limit":30}`;
        try {
            const response = await get(url);
            if (response && response.data) {
                setMeasurements(response.data);
                console.log("response.data....", response.data)
            }
        } catch (error) {
            console.error('Error fetching measurements:', error);
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        if (open) {
            fetchData();
        }
    }, [open]);

    const handleEditClick = (measurement) => {
        console.log(measurement.id)
        setEditingId(measurement.id);
        setEditableFields({ value: measurement.value, unit: measurement.unit });
    };

    const handleEditClose = () => {
        setEditDialogOpen(false);
        setSelectedMeasurement(null);
    };

    const handleSave = () => {
        // Add logic to save changes, e.g., call an API to update the measurement
        console.log('Updated Measurement:', selectedMeasurement);
        handleEditClose();
    };

    const handleFieldChange = (field, value) => {
        setSelectedMeasurement({ ...selectedMeasurement, [field]: value });
    };

    const handleCancel = () => {

    }
    return (
        <>
            {/* Main Dialog */}
            <Dialog
                fullWidth
                open={open}
                onClose={onClose}
                aria-labelledby="measurement-dialog-title"
            >
                <DialogTitle id="measurement-dialog-title">Add Weight</DialogTitle>
                <DialogTitle id="measurement-dialog-title"><NeckSizeGraph type={type} showLine={true} /></DialogTitle>
                <DialogContent>
                    {loading ? (
                        <div style={{ textAlign: 'center', padding: '20px' }}>
                            <CircularProgress />
                        </div>
                    ) : measurements.length > 0 ? (
                        <div>
                            {measurements.map((measurement) => (
                                <Box
                                    key={measurement.id}
                                    display="flex"
                                    alignItems="center"
                                    justifyContent="space-between"
                                    padding="8px 0"
                                    borderBottom="1px solid #f0f0f0"
                                >
                                    {/* Left Side: Date */}
                                    <Typography variant="body2">
                                        <DateShow date={measurement.recordedAt} />
                                    </Typography>

                                    {/* Right Side: Value and Edit Icon */}
                                    <Box display="flex" alignItems="center" gap={1}>
                                        <Typography variant="body2">
                                            {measurement.value} {measurement.unit}
                                        </Typography>
                                        <IconButton onClick={() => handleEditClick(measurement)}>
                                            <EditIcon sx={{ color: 'primary.main' }} />
                                        </IconButton>
                                    </Box>
                                    {editingId === measurement.id && (
                                        <Box display="flex" alignItems="center" gap={2} marginTop={2}>
                                            <TextField
                                                label="Value"
                                                variant="outlined"
                                                value={editableFields.value}
                                                onChange={(e) => handleFieldChange('value', e.target.value)}
                                                size="small"
                                            />
                                            <TextField
                                                label="Unit"
                                                variant="outlined"
                                                value={editableFields.unit}
                                                onChange={(e) => handleFieldChange('unit', e.target.value)}
                                                size="small"
                                            />
                                            <IconButton onClick={() => handleSave(measurement.id)}>
                                                {/* <SaveIcon sx={{ color: 'green' }} /> */}
                                                Update
                                            </IconButton>
                                            <IconButton onClick={handleCancel}>
                                                <DeleteIcon sx={{ color: 'red' }} />
                                            </IconButton>
                                        </Box>
                                    )}
                                </Box>

                            ))}
                        </div>
                    ) : (
                        <Typography>No measurements available.</Typography>
                    )}
                </DialogContent>
                <DialogActions>
                    <Button onClick={onClose}>Cancel</Button>
                </DialogActions>
            </Dialog>

            {/* Edit Dialog */}
            {/* <Dialog
                fullWidth
                open={editDialogOpen}
                onClose={handleEditClose}
                aria-labelledby="edit-measurement-dialog-title"
            >
                <DialogTitle id="edit-measurement-dialog-title">
                    Edit Measurement
                </DialogTitle>
                <DialogContent>
                    {selectedMeasurement && (
                        <Box display="flex" flexDirection="column" gap={2}>
                            <TextField
                                label="Value"
                                variant="outlined"
                                value={selectedMeasurement.value}
                                onChange={(e) => handleFieldChange('value', e.target.value)}
                            />
                            <TextField
                                label="Unit"
                                variant="outlined"
                                value={selectedMeasurement.unit}
                                onChange={(e) => handleFieldChange('unit', e.target.value)}
                            />
                        </Box>
                    )}
                </DialogContent>
                <DialogActions>
                    <Button onClick={handleEditClose}>Cancel</Button>
                    <Button onClick={handleSave} variant="contained" color="primary">
                        Save
                    </Button>
                </DialogActions>
            </Dialog> */}
        </>
    );
}

// import React, { useState, useEffect } from 'react';
// import { get } from '../../../services/api-services';
// import DateShow from '../../date-filed/DateShow';
// import EditIcon from '@mui/icons-material/Edit';
// import DeleteIcon from '@mui/icons-material/Delete';
// import {
//     Grid, IconButton, Typography, Box, TextField, Button, CircularProgress,
// } from '@mui/material';

// export default function AddMeasurementDialog({ open, onClose, type }) {
//     const [measurements, setMeasurements] = useState([]);
//     const [loading, setLoading] = useState(true);
//     const [editingId, setEditingId] = useState(null);
//     const [editableFields, setEditableFields] = useState({ value: '', unit: '' });

//     const fetchData = async () => {
//         const url = `/Measurements?filter={"where":{"customerId":"12345","type":"${type}"},"order":"recordedAt DESC","limit":30}`;
//         try {
//             const response = await get(url);
//             if (response && response.data) {
//                 setMeasurements(response.data);
//             }
//         } catch (error) {
//             console.error('Error fetching measurements:', error);
//         } finally {
//             setLoading(false);
//         }
//     };

//     useEffect(() => {
//         if (open) {
//             fetchData();
//         }
//     }, [open]);

//     const handleEditClick = (measurement) => {
//         setEditingId(measurement.id);
//         setEditableFields({ value: measurement.value, unit: measurement.unit });
//     };

//     const handleSave = () => {
//         // Add logic to save changes (e.g., API call)
//         console.log('Saved Measurement:', editableFields);
//         // Reset editing state
//         setEditingId(null);
//         setEditableFields({ value: '', unit: '' });
//     };

//     const handleCancel = () => {
//         setEditingId(null);
//         setEditableFields({ value: '', unit: '' });
//     };

//     return (
// <>
//     {loading ? (
//         <CircularProgress />
//     ) : measurements.length > 0 ? (
//         <Box>
//             {measurements.map((measurement) => (
//                 <Box key={measurement.id} borderBottom="1px solid #f0f0f0" padding="8px 0">
//                     {/* Row Content */}
//                     <Box display="flex" alignItems="center" justifyContent="space-between">
//                         <Typography variant="body2">
//                             <DateShow date={measurement.recordedAt} />
//                         </Typography>
//                         <Box display="flex" alignItems="center" gap={1}>
//                             <Typography variant="body2">
//                                 {measurement.value} {measurement.unit}
//                             </Typography>
//                             <IconButton onClick={() => handleEditClick(measurement)}>
//                                 <EditIcon sx={{ color: 'primary.main' }} />
//                             </IconButton>
//                         </Box>
//                     </Box>

//                     {/* Editable Fields */}
//                     {editingId === measurement.id && (
//                         <Box display="flex" alignItems="center" gap={2} marginTop={2}>
//                             <TextField
//                                 label="Value"
//                                 variant="outlined"
//                                 value={editableFields.value}
//                                 onChange={(e) => setEditableFields({
//                                     ...editableFields,
//                                     value: e.target.value,
//                                 })}
//                                 size="small"
//                             />
//                             <TextField
//                                 label="Unit"
//                                 variant="outlined"
//                                 value={editableFields.unit}
//                                 onChange={(e) => setEditableFields({
//                                     ...editableFields,
//                                     unit: e.target.value,
//                                 })}
//                                 size="small"
//                             />
//                             <Button
//                                 variant="contained"
//                                 color="primary"
//                                 onClick={handleSave}
//                             >
//                                 Save
//                             </Button>
//                             <Button
//                                 variant="outlined"
//                                 color="secondary"
//                                 onClick={handleCancel}
//                             >
//                                 Cancel
//                             </Button>
//                         </Box>
//                     )}
//                 </Box>
//             ))}
//         </Box>
//     ) : (
//         <Typography>No measurements available.</Typography>
//     )}
// </>
//     );
// }



import React, { useEffect, useState } from "react";
import { Box, Button, CircularProgress, Snackbar, Typography, Divider, Grid, Card, CardContent, IconButton } from "@mui/material";
import { useNavigate, useParams } from "react-router-dom";
import { api } from "../../../Db.connection";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import EditIcon from '@mui/icons-material/Edit';
import EditProgressBar from "../profileModel-DialogBox/EditProgressBar";
const WeightProgress = () => {
    const [weightData, setWeightData] = useState({
        id: null,
        startWeight: null,
        currentWeight: null,
        targetWeight: 0,
        startWeightBMI: null,
        currentWeightBMI: null,
        weightGoalPercent: 0,
    });
    const [loading, setLoading] = useState(true);
    const [snackbar, setSnackbar] = useState({ open: false, message: "" });
    const [opneDialog, setOpneDialog] = useState(false)
    const navigate = useNavigate();
    const { id } = useParams();

    const getWeightData = async () => {
        const accessToken = localStorage.getItem("accessToken");
        if (!accessToken) {
            setSnackbar({ open: true, message: "Access token is missing" });
            return;
        }

        const url = `/Measurements?filter={"where": {"customerId": "${id}", "type": "weight"}, "order" : "recordedAt DESC"}&access_token=${accessToken}`;
        try {
            const response = await api.get(url);
            const data = response.data;

            if (data.length > 0 && data[0].value != null) {
                const startWeight = data.slice(-1)[0].value;
                const currentWeight = data[0].value;
                const targetWeight = data[0].targetWeight || 0;
                setWeightData({
                    id: data[0].id,  // Set the id
                    startWeight,
                    currentWeight,
                    targetWeight,
                    startWeightBMI: calculateBMI(startWeight),
                    currentWeightBMI: calculateBMI(currentWeight),
                    weightGoalPercent: targetWeight > 0 ? ((currentWeight / targetWeight) * 100) : 0,
                });
            } else {
                setWeightData({ currentWeight: "", startWeight: "", targetWeight: 0 });
            }
        } catch (error) {
            if (error.response?.status === 401) {
                setSnackbar({ open: true, message: "Login expired, please login again." });
                localStorage.clear();
                navigate("/login");
            } else {
                console.error("Error fetching weight data", error);
            }
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        getWeightData();
    },[]);

    const calculateBMI = (weight) => {
        const height = 170; // replace with actual user height if available
        const heightInMeters = height / 100;
        return (weight / (heightInMeters * heightInMeters)).toFixed(2);
    };

    const handleSnackbarClose = () => setSnackbar({ open: false, message: "" });
    const handleGoBack = () => {
        navigate(-1); // Go back to the previous page
    };

    if (loading) {
        return (
            <Box sx={{ display: "flex", justifyContent: "center", alignItems: "center", minHeight: "100vh" }}>
                <CircularProgress />
            </Box>
        );
    }

    return (
        <Box>
            <Card >
                <CardContent className="">
                    {/* <Grid container alignItems="center" justifyContent="space-between" spacing={2}> */}
                    <Grid container alignItems="center" justifyContent="space-between" spacing={2}>
                        {/* Title on the left */}
                        <Grid item>
                            <Typography variant="h5" sx={{ fontWeight: 600 }}>
                                Weight Progress
                            </Typography>
                        </Grid>

                        {/* Icon on the right */}
                        <Grid item>
                            <EditIcon
                                onClick={(e) => {
                                    setOpneDialog(true);
                                }} />
                        </Grid>
                    </Grid>

                    {/* </Grid> */}

                    {/* <Divider sx={{ mb: 3 }} /> */}
                    <Grid container spacing={3} direction="column" alignItems="center" >
                        {/* Progress Section */}
                        <Grid item xs={12}>
                            <Typography variant="h6" align="center">Progress</Typography>
                            <Box sx={{ display: "flex", alignItems: "center", justifyContent: "center", width: "100%", height: 200 }}>
                                <CircularProgress
                                    variant="determinate"
                                    value={weightData.weightGoalPercent || 0}
                                    size={150}
                                    thickness={5}
                                    sx={{ color: "#4caf50" }}
                                />
                                <Typography variant="h5">{weightData.weightGoalPercent}%</Typography>
                            </Box>
                        </Grid>

                        {/* <Divider sx={{ width: "100%", my: 3 }} /> */}

                        {/* Start, Current, and Target Sections */}
                        <Grid item xs={12}>
                            <Grid container spacing={3} justifyContent="center">
                                {/* Start */}
                                <Grid item xs={12} sm={4} textAlign="center">
                                    <Typography variant="h6">Start</Typography>
                                    <Typography variant="h4">{weightData.startWeight || 0} kgs</Typography>
                                    <Typography variant="body2">BMI: {weightData.startWeightBMI}</Typography>
                                </Grid>

                                {/* Current */}
                                <Grid item xs={12} sm={4} textAlign="center">
                                    <Typography variant="h6">Current</Typography>
                                    <Typography variant="h4">{weightData.currentWeight || 0} kgs</Typography>
                                    <Typography variant="body2">BMI: {weightData.currentWeightBMI}</Typography>
                                </Grid>

                                {/* Target */}
                                <Grid item xs={12} sm={4} textAlign="center">
                                    <Typography variant="h6">Target</Typography>
                                    <Typography variant="h4">{weightData.weightGoal || 0} kgs</Typography>
                                    <Typography variant="body2">
                                        Target BMI: {calculateBMI(weightData.weightGoal || 0)}
                                    </Typography>
                                </Grid>
                            </Grid>
                        </Grid>
                    </Grid>

                </CardContent>
            </Card>
            <EditProgressBar
                open={opneDialog}
                onClose={() => setOpneDialog(false)}
                id={id}
                data={weightData}

            />
            <Snackbar
                open={snackbar.open}
                autoHideDuration={3000}
                message={snackbar.message}
                onClose={handleSnackbarClose}
            />
        </Box>
    );
};

export default WeightProgress;






// // import React, { useState, useEffect } from 'react';
// // import { Line } from 'react-chartjs-2';
// // import { CircularProgress, Typography, Box } from '@mui/material';
// // import { get } from '../../../services/api-services';
// // import { useParams } from 'react-router-dom';

// // import {
// //     Chart as ChartJS,
// //     CategoryScale,
// //     LinearScale,
// //     PointElement,
// //     LineElement,
// //     Title,
// //     Tooltip,
// //     Legend,
// //     TimeScale,
// // } from 'chart.js';
// // import 'chartjs-adapter-date-fns';

// // Register Chart.js modules
// //ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend, TimeScale);

// // const NeckSizeGraph = ({ type }) => {
// //     const { id } = useParams(); // Customer ID from the URL
// //     const [labels, setLabels] = useState([]);
// //     const [data, setData] = useState([]);
// //     const [loading, setLoading] = useState(true);

// //     // Fetch data on component mount
// //     useEffect(() => {
// //         const fetchData = async () => {
// //             const url = `/Measurements?filter={"where":{"customerId":"${id}","type":"${type}"},"order":"recordedAt DESC","limit":30}`;
// //             try {
// //                 const response = await get(url);
// //                 if (response && response.data) {
// //                     // Format the dates and values
// //                     const labelData = response.data.map((item) =>
// //                         new Date(item.recordedAt).toISOString()
// //                     );
// //                     const valueData = response.data.map((item) =>
// //                         parseFloat(item.value)
// //                     );

// //                     setLabels(labelData);
// //                     setData(valueData);
// //                 }
// //             } catch (error) {
// //                 console.error('Error fetching graph data:', error);
// //             } finally {
// //                 setLoading(false);
// //             }
// //         };

// //         fetchData();
// //     }, [id, type]);

// //     if (loading) {
// //         return (
// //             <Box textAlign="center" py={2}>
// //                 <CircularProgress />
// //                 <Typography variant="body2" mt={1}>
// //                     Loading Graph...
// //                 </Typography>
// //             </Box>
// //         );
// //     }

// //     // Calculate the minimum and maximum values for the y-axis
// //     const minValue = Math.min(...data);
// //     const maxValue = Math.max(...data);

// //     const chartOptions = {
// //         responsive: true,
// //         plugins: {
// //             legend: {
// //                 display: true,
// //                 position: 'top',
// //             },
// //             title: {
// //                 display: true,
// //                 text: `${type} Measurements Over Time`,
// //             },
// //         },
// //         scales: {
// //             x: {
// //                 type: 'time',
// //                 time: {
// //                     unit: 'day',
// //                     displayFormats: {
// //                         day: 'MMM dd, yyyy',
// //                     },
// //                 },
// //                 title: {
// //                     display: true,
// //                     text: 'Date',
// //                 },
// //             },
// //             y: {
// //                 beginAtZero: false, // Allow dynamic scaling
// //                 min: minValue, // Smallest value in the dataset
// //                 max: maxValue, // Largest value in the dataset
// //                 title: {
// //                     display: true,
// //                     text: `${type}`,
// //                 },
// //             },
// //         },
// //     };

// //     const chartData = {
// //         labels,
// //         datasets: [
// //             {
// //                 label: `${type} Measurements`,
// //                 data,
// //                 fill: true,
// //                 borderColor: 'rgba(75, 192, 192, 1)',
// //                 backgroundColor: 'rgba(75, 192, 192, 0.2)',
// //                 pointBackgroundColor: 'rgba(75, 192, 192, 1)',
// //                 tension: 0.4,
// //             },
// //         ],
// //     };

// //     return (
// //         <Box width="100%" mx="auto" maxWidth="600px" mt={3}>
// //             <Line data={chartData} options={chartOptions} />
// //         </Box>
// //     );
// // };

// import { useState, useEffect } from 'react';
// import { Line } from 'react-chartjs-2';
// import { useParams } from 'react-router-dom';
// import { get } from 'axios'; // Assuming `get` is from Axios
// import { Box, CircularProgress, Typography } from '@mui/material';

// const formatDate = (date) => {
//     const options = { day: 'numeric', month: 'short', year: 'numeric' };
//     return new Intl.DateTimeFormat('en-GB', options).format(new Date(date));
// };

// const customFilterDates = (dates) => {
//     const uniqueDates = [];
//     dates.forEach((date, index) => {
//         const day = new Date(date).getDate();
//         if (index === 0 || day === 1 || day % 9 === 0) {
//             uniqueDates.push(date);
//         }
//     });
//     return uniqueDates;
// };

// const NeckSizeGraph = ({ type }) => {
//     const { id } = useParams(); // Customer ID from the URL
//     const [labels, setLabels] = useState([]);
//     const [data, setData] = useState([]);
//     const [loading, setLoading] = useState(true);

//     useEffect(() => {
//         const fetchData = async () => {
//             const url = `/Measurements?filter={"where":{"customerId":"${id}","type":"${type}"},"order":"recordedAt DESC","limit":30}`;
//             try {
//                 const response = await get(url);
//                 if (response && response.data) {
//                     const labelData = response.data.map((item) =>
//                         new Date(item.recordedAt).toISOString()
//                     );
//                     const valueData = response.data.map((item) =>
//                         parseFloat(item.value)
//                     );

//                     // Apply date formatting and filtering
//                     const formattedDates = labelData.map(formatDate);
//                     const filteredDates = customFilterDates(labelData);

//                     setLabels(filteredDates.map(formatDate)); // Set formatted and filtered labels
//                     setData(valueData.slice(0, filteredDates.length)); // Adjust data length to match filtered labels
//                 }
//             } catch (error) {
//                 console.error('Error fetching graph data:', error);
//             } finally {
//                 setLoading(false);
//             }
//         };

//         fetchData();
//     }, [id, type]);

//     if (loading) {
//         return (
//             <Box textAlign="center" py={2}>
//                 <CircularProgress />
//                 <Typography variant="body2" mt={1}>
//                     Loading Graph...
//                 </Typography>
//             </Box>
//         );
//     }

//     const minValue = Math.min(...data);
//     const maxValue = Math.max(...data);

//     const chartOptions = {
//         responsive: true,
//         plugins: {
//             legend: {
//                 display: true,
//                 position: 'top',
//             },
//             title: {
//                 display: true,
//                 text: `${type} Measurements Over Time`,
//             },
//         },
//         scales: {
//             x: {
//                 type: 'category', // Use category for custom x-axis labels
//                 labels, // Use filtered and formatted labels
//                 title: {
//                     display: true,
//                     text: 'Date',
//                 },
//             },
//             y: {
//                 beginAtZero: false,
//                 min: minValue,
//                 max: maxValue,
//                 title: {
//                     display: true,
//                     text: `${type}`,
//                 },
//             },
//         },
//     };

//     const chartData = {
//         labels,
//         datasets: [
//             {
//                 label: `${type} Measurements`,
//                 data,
//                 fill: true,
//                 borderColor: 'rgba(75, 192, 192, 1)',
//                 backgroundColor: 'rgba(75, 192, 192, 0.2)',
//                 pointBackgroundColor: 'rgba(75, 192, 192, 1)',
//                 tension: 0.4,
//             },
//         ],
//     };

//     return (
//         <Box width="100%" mx="auto" maxWidth="600px" mt={3}>
//             <Line data={chartData} options={chartOptions} />
//         </Box>
//     );
// };

// export default NeckSizeGraph;

// import { useState, useEffect } from 'react';
// import { Line } from 'react-chartjs-2';
// import { useParams } from 'react-router-dom';
// import { get } from '../../../services/api-services';
// import { Box, CircularProgress, Typography } from '@mui/material';

// const formatDate = (date) => {
//     const options = { day: 'numeric', month: 'short', year: 'numeric' };
//     return new Intl.DateTimeFormat('en-GB', options).format(new Date(date));
// };


// const filterAlternateDates = (data) => {
//     return data.filter((_, index) => index % 2 === 0); // Only keep alternate items (1, 3, 5, etc.)
// };

// // console.log(filterOddDates(response.data));

// const NeckSizeGraph = ({ type }) => {
//     const { id } = useParams(); // Customer ID from the URL
//     const [labels, setLabels] = useState([]);
//     const [data, setData] = useState([]);
//     const [loading, setLoading] = useState(true);

//     useEffect(() => {
//         const fetchData = async () => {
//             const url = `/Measurements?filter={"where":{"customerId":"${id}","type":"${type}"},"order":"recordedAt DESC","limit":30}`;
//             try {
//                 const response = await get(url);
//                 if (response && response.data) {
//                     // Filter and format data
//                     const filteredData = filterAlternateDates(response.data);
//                     const labelData = filteredData.map((item) =>
//                         formatDate(item.recordedAt)
//                     );
//                     const valueData = filteredData.map((item) =>
//                         parseFloat(item.value)
//                     );

//                     setLabels(labelData);
//                     setData(valueData);
//                 }
//             } catch (error) {
//                 console.error('Error fetching graph data:', error);
//             } finally {
//                 setLoading(false);
//             }
//         };

//         fetchData();
//     }, [id, type]);

//     if (loading) {
//         return (
//             <Box textAlign="center" py={2}>
//                 <CircularProgress />
//                 <Typography variant="body2" mt={1}>
//                     Loading Graph...
//                 </Typography>
//             </Box>
//         );
//     }

//     const minValue = Math.min(...data);
//     const maxValue = Math.max(...data);

//     const chartOptions = {
//         responsive: true,
//         plugins: {
//             legend: {
//                 display: true,
//                 position: 'top',
//             },
//             title: {
//                 display: true,
//                 text: `${type} Measurements Over Time`,
//             },
//         },
//         scales: {
//             x: {
//                 type: 'category', 
//                 labels,
//                 title: {
//                     display: true,
//                     text: 'Date',
//                 },
//             },
//             y: {
//                 beginAtZero: false,
//                 min: minValue,
//                 max: maxValue,
//                 title: {
//                     display: true,
//                     text: `${type}`,
//                 },
//             },
//         },
//     };

//     const chartData = {
//         labels,
//         datasets: [
//             {
//                 label: `${type} Measurements`,
//                 data,
//                 fill: true,
//                 borderColor: 'rgba(75, 192, 192, 1)',
//                 backgroundColor: 'rgba(75, 192, 192, 0.2)',
//                 pointBackgroundColor: 'rgba(75, 192, 192, 1)',
//                 tension: 0.4,
//             },
//         ],
//     };

//     return (
//         <Box width="100%" mx="auto" maxWidth="600px" mt={3}>
//             <Line data={chartData} options={chartOptions} />
//         </Box>
//     );
// };

// export default NeckSizeGraph;




// import { useState, useEffect } from 'react';
// import { Line } from 'react-chartjs-2';
// import { useParams } from 'react-router-dom';
// import { get } from '../../../services/api-services';
// import { Box, CircularProgress, Typography } from '@mui/material';

// const formatDate = (date) => {
//     const options = { day: 'numeric', month: 'short', year: 'numeric' };
//     return new Intl.DateTimeFormat('en-GB', options).format(new Date(date));
// };

// const filterAlternateDates = (data) => {
//     return data.filter((_, index) => index % 2 === 0); // Only keep alternate items (1, 3, 5, etc.)
// };

// const NeckSizeGraph = ({ type }) => {
//     const { id } = useParams(); // Customer ID from the URL
//     const [labels, setLabels] = useState([]);
//     const [data, setData] = useState([]);
//     const [loading, setLoading] = useState(true);

//     useEffect(() => {
//         const fetchData = async () => {
//             const url = `/Measurements?filter={"where":{"customerId":"${id}","type":"${type}"},"order":"recordedAt DESC","limit":30}`;
//             try {
//                 const response = await get(url);
//                 if (response && response.data) {
//                     // Filter and format data
//                     const filteredData = filterAlternateDates(response.data);
                    
//                     // Reverse data for left-to-right order
//                     const reversedData = filteredData.reverse();

//                     const labelData = reversedData.map((item) =>
//                         formatDate(item.recordedAt)
//                     );
//                     const valueData = reversedData.map((item) =>
//                         parseFloat(item.value)
//                     );

//                     setLabels(labelData);
//                     setData(valueData);
//                 }
//             } catch (error) {
//                 console.error('Error fetching graph data:', error);
//             } finally {
//                 setLoading(false);
//             }
//         };

//         fetchData();
//     }, [id, type]);

//     if (loading) {
//         return (
//             <Box textAlign="center" py={2}>
//                 <CircularProgress />
//                 <Typography variant="body2" mt={1}>
//                     Loading Graph...
//                 </Typography>
//             </Box>
//         );
//     }

//     const minValue = Math.min(...data);
//     const maxValue = Math.max(...data);

//     // const chartOptions = {
//     //     responsive: true,
//     //     plugins: {
//     //         legend: {
//     //             display: true,
//     //             position: 'top',
//     //         },
//     //         title: {
//     //             display: true,
//     //             text: `${type} Measurements Over Time`,
//     //         },
//     //     },
//     //     scales: {
//     //         x: {
//     //             display: true,
//     //             labels,
//     //             title: {
//     //                 display: true,
//     //                 text: 'Date',
//     //             },
//     //             grid: {
//     //                 display: false,
//     //             },
//     //         },
//     //         y: {
//     //             display: true,
//     //             beginAtZero: false,
//     //             min: minValue,
//     //             max: maxValue,
//     //             title: {
//     //                 display: true,
//     //                 text: `${type}`,
//     //             },
//     //             grid: {
//     //                 display: false,
//     //             },
//     //         },
//     //     },
//     //     backgroundColor: 'rgba(255, 255, 255, 1)',  // Background of the chart area
//     //     layout: {
//     //         backgroundColor: 'rgba(0, 123, 255, 0.1)', // Background behind the graph area
//     //     },
//     // };
    
//     const chartOptions = {
//         responsive: true,
//         plugins: {
//             legend: {
//                 display: true,
//                 position: 'top',
//             },
//             title: {
//                 display: true,
//                 text: `${type} Measurements Over Time`,
//             },
//         },
//         scales: {
//             x: {
//                 display: false, // Hide the X-axis line
//                 labels,
//                 title: {
//                     display: true,
//                     text: 'Date',
//                 },
//             },
//             y: {
//                 display: false, // Hide the Y-axis line
//                 beginAtZero: false,
//                 min: minValue,
//                 max: maxValue,
//                 title: {
//                     display: true,
//                     text: `${type}`,
//                 },
//             },
//         },
//     };
    

//     const chartData = {
//         labels,
//         datasets: [
//             {
//                 label: `${type} Measurements`,
//                 data,
//                 fill: true,
//                 borderColor: 'rgba(75, 192, 192, 1)',
//                 backgroundColor: 'rgba(75, 192, 192, 0.2)',
//                 pointBackgroundColor: 'rgba(75, 192, 192, 1)',
//                 tension: 0.4,
//             },
//         ],
//     };

//     return (
//         <Box width="100%" mx="auto" maxWidth="600px" mt={3}>
//             <Line data={chartData} options={chartOptions} />
//         </Box>
//     );
// };

// export default NeckSizeGraph;




import { useState, useEffect } from 'react';
import { Line } from 'react-chartjs-2';
import { useParams } from 'react-router-dom';
import { get } from '../../../services/api-services';
import { Box, CircularProgress, Typography } from '@mui/material';

// Import the necessary components from Chart.js
import { Chart as ChartJS, CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend } from 'chart.js';

// Register the components
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

const formatDate = (date) => {
    const options = { day: 'numeric', month: 'short', year: 'numeric' };
    return new Intl.DateTimeFormat('en-GB', options).format(new Date(date));
};

const filterAlternateDates = (data) => {
    return data.filter((_, index) => index % 2 === 0); // Only keep alternate items (1, 3, 5, etc.)
};

const NeckSizeGraph = ({ type, showLine }) => {  // Accept showLine as a prop
    const { id } = useParams(); // Customer ID from the URL
    const [labels, setLabels] = useState([]);
    const [data, setData] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const fetchData = async () => {
            const url = `/Measurements?filter={"where":{"customerId":"${id}","type":"${type}"},"order":"recordedAt DESC","limit":30}`;
            try {
                const response = await get(url);
                if (response && response.data) {
                    // Filter and format data
                    const filteredData = filterAlternateDates(response.data);
                    
                    // Reverse data for left-to-right order
                    const reversedData = filteredData.reverse();

                    const labelData = reversedData.map((item) =>
                        formatDate(item.recordedAt)
                    );
                    const valueData = reversedData.map((item) =>
                        parseFloat(item.value)
                    );

                    setLabels(labelData);
                    setData(valueData);
                }
            } catch (error) {
                console.error('Error fetching graph data:', error);
            } finally {
                setLoading(false);
            }
        };

        fetchData();
    }, [id, type]);

    if (loading) {
        return (
            <Box textAlign="center" py={2}>
                <CircularProgress />
                <Typography variant="body2" mt={1}>
                    Loading Graph...
                </Typography>
            </Box>
        );
    }

    const minValue = Math.min(...data);
    const maxValue = Math.max(...data);

    // Chart option with line
    const chartOptionsWithLine = {
        responsive: true,
        plugins: {
            legend: {
                display: true,
                position: 'top',
            },
            title: {
                display: true,
                text: `${type} Measurements Over Time`,
            },
        },
        scales: {
            x: {
                display: true,
                type: 'category', // Use category scale for X-axis
                labels,
                title: {
                    display: true,
                    text: 'Date',
                },
            },
            y: {
                display: true,
                beginAtZero: false,
                min: minValue,
                max: maxValue,
                title: {
                    display: true,
                    text: `${type}`,
                },
            },
        },
    };

    // Chart option without line
    const chartOptionsWithoutLine = {
        responsive: true,
        plugins: {
            // legend: {
            //     display: true,
            //     position: 'top',
            // },
            // title: {
            //     display: true,
            //     text: `${type} Measurements Over Time (No Line)`,
            // },
        },
        scales: {
            x: {
                display: false, // Hide the X-axis line
                labels,
                title: {
                    display: true,
                    text: 'Date',
                },
            },
            y: {
                display: false, // Hide the Y-axis line
                beginAtZero: false,
                min: minValue,
                max: maxValue,
                title: {
                    display: true,
                    text: `${type}`,
                },
            },
        },
    };

    const chartData = {
        labels,
        datasets: [
            {
                label: `${type} Measurements`,
                data,
                fill: true,
                borderColor: 'rgba(75, 192, 192, 1)',
                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                pointBackgroundColor: 'rgba(75, 192, 192, 1)',
                tension: 0.4,
            },
        ],
    };

    // Conditionally render the graph based on the `showLine` prop
    const chartOptions = showLine ? chartOptionsWithLine : chartOptionsWithoutLine;

    return (
        <Box width="100%" mx="auto" maxWidth="600px" mt={3}>
            <Typography variant="h6" textAlign="center">
                {/* {showLine ? 'Graph with Line' : 'Graph without Line'} */}
            </Typography>
            <Line data={chartData} options={chartOptions} />
        </Box>
    );
};

export default NeckSizeGraph;
